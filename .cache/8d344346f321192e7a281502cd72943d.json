{"dependencies":[{"name":"C:\\Users\\Luis Herasme\\Desktop\\LienzoEngine\\node_modules\\vector_class\\tsconfig.json","includedInParent":true,"mtime":1513546872000},{"name":"C:\\Users\\Luis Herasme\\Desktop\\LienzoEngine\\node_modules\\vector_class\\package.json","includedInParent":true,"mtime":1531327400609},{"name":"C:\\Users\\Luis Herasme\\Desktop\\LienzoEngine\\package.json","includedInParent":true,"mtime":1531329788790}],"generated":{"js":"\"use strict\";\r\nexports.__esModule = true;\r\nvar Vector3D = /** @class */ (function () {\r\n    function Vector3D(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    Vector3D.prototype.add = function (vector) {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n        this.z += vector.z;\r\n    };\r\n    Vector3D.prototype.sub = function (vector) {\r\n        this.x -= vector.x;\r\n        this.y -= vector.y;\r\n        this.z -= vector.z;\r\n    };\r\n    Vector3D.prototype.mult = function (scalar) {\r\n        this.x *= scalar;\r\n        this.y *= scalar;\r\n        this.z *= scalar;\r\n    };\r\n    Vector3D.prototype.div = function (scalar) {\r\n        this.x /= scalar;\r\n        this.y /= scalar;\r\n        this.z /= scalar;\r\n    };\r\n    Vector3D.prototype.inverse = function () {\r\n        this.x *= -1;\r\n        this.y *= -1;\r\n        this.z *= -1;\r\n    };\r\n    Vector3D.prototype.mag = function () {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n    };\r\n    Vector3D.prototype.dot = function (vector) {\r\n        return this.x * vector.x + this.y * vector.y + this.z * vector.z;\r\n    };\r\n    Vector3D.prototype.distance = function (vector) {\r\n        return Vector3D.sub(this, vector).mag();\r\n    };\r\n    Vector3D.prototype.angle = function () {\r\n        return Math.atan2(this.y, this.x);\r\n    };\r\n    Vector3D.prototype.copy = function () {\r\n        return new Vector3D(this.x, this.y, this.z);\r\n    };\r\n    Vector3D.prototype.normalize = function () {\r\n        this.div(this.mag());\r\n    };\r\n    Vector3D.prototype.setMag = function (mag) {\r\n        this.normalize();\r\n        this.mult(mag);\r\n    };\r\n    Vector3D.prototype.setAngle = function (angle) {\r\n        var magnitude = this.mag();\r\n        this.x = magnitude * Math.cos(angle);\r\n        this.y = magnitude * Math.sin(angle);\r\n    };\r\n    Vector3D.prototype.addAngle = function (angle) {\r\n        this.setAngle(this.angle() + angle);\r\n    };\r\n    Vector3D.prototype.limit = function (scalar) {\r\n        if (this.mag() > scalar) {\r\n            this.setMag(scalar);\r\n        }\r\n    };\r\n    Vector3D.prototype.moveTowards = function (vector, speed, stop) {\r\n        if (this.distance(vector) > stop) {\r\n            var unit = Vector3D.normalize(vector);\r\n            unit.mult(speed);\r\n            this.add(unit);\r\n        }\r\n    };\r\n    Vector3D.prototype.zero = function () {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n    };\r\n    Vector3D.add = function (vector1, vector2) {\r\n        return new Vector3D(vector1.x + vector2.x, vector1.y + vector2.y, vector1.z + vector2.z);\r\n    };\r\n    Vector3D.sub = function (vector1, vector2) {\r\n        return new Vector3D(vector1.x - vector2.x, vector1.y - vector2.y, vector1.z - vector2.z);\r\n    };\r\n    Vector3D.mult = function (vector, scalar) {\r\n        return new Vector3D(vector.x * scalar, vector.y * scalar, vector.z * scalar);\r\n    };\r\n    Vector3D.div = function (vector, scalar) {\r\n        return new Vector3D(vector.x / scalar, vector.y / scalar, vector.z / scalar);\r\n    };\r\n    Vector3D.inverse = function (vector) {\r\n        return new Vector3D(vector.x * -1, vector.y * -1, vector.z * -1);\r\n    };\r\n    Vector3D.distance = function (vector1, vector2) {\r\n        return this.sub(vector1, vector2).mag();\r\n    };\r\n    Vector3D.normalize = function (vector) {\r\n        return this.div(vector, vector.mag());\r\n    };\r\n    Vector3D.cross = function (vector1, vector2) {\r\n        return vector1.x * vector2.y - vector2.x * vector1.y;\r\n    };\r\n    Vector3D.random = function (x, y, z) {\r\n        if (Math.random() > 0.5) {\r\n            return new Vector3D(x * Math.random(), y * Math.random(), z * Math.random());\r\n        }\r\n        else {\r\n            return new Vector3D(-x * Math.random(), -y * Math.random(), -z * Math.random());\r\n        }\r\n    };\r\n    return Vector3D;\r\n}());\r\nexports[\"default\"] = Vector3D;\r\n/*\r\n\r\nTO ADD\r\n\r\nimport vector from '../vector'\r\n\r\nfunction rotate (x, y, z, center, vec) {\r\n  let vecR\r\n  vecR = vector.sub(vec, center)\r\n  vecR = rotateX(vecR, x)\r\n  vecR = rotateY(vecR, y)\r\n  vecR = rotateZ(vecR, z)\r\n  vecR = vector.add(vecR, center)\r\n  return vecR\r\n}\r\n\r\nfunction rotateX (vec, t) {\r\n  let vecR = vec\r\n  let newy = vec[1] * Math.cos(t) - vec[2] * Math.sin(t)\r\n  let newz = vec[1] * Math.sin(t) + vec[2] * Math.cos(t)\r\n  vecR[1] = newy\r\n  vecR[2] = newz\r\n  return vecR\r\n}\r\n\r\nfunction rotateY (vec, t) {\r\n  let vecR = vec\r\n  let newz = vec[2] * Math.cos(t) - vec[0] * Math.sin(t)\r\n  let newx = vec[2] * Math.sin(t) + vec[0] * Math.cos(t)\r\n  vecR[2] = newz\r\n  vecR[0] = newx\r\n  return vecR\r\n}\r\n\r\nfunction rotateZ (vec, t) {\r\n  let vecR = vec\r\n  let newx = vec[0] * Math.cos(t) - vec[1] * Math.sin(t)\r\n  let newy = vec[0] * Math.sin(t) + vec[1] * Math.cos(t)\r\n  vecR[0] = newx\r\n  vecR[1] = newy\r\n  return vecR\r\n}\r\n\r\nconst memlength = (vec) => Math.pow(Math.pow(vec[0], 2) + Math.pow(vec[1], 2) + Math.pow(vec[2], 2), 0.5)\r\n\r\nconst normal = (v1, v2, v3) => vector.cross(vector.sub(v2, v1), vector.sub(v3, v1))\r\n\r\nfunction isInTriangle (vec, triangle) {\r\n  let u = vector.sub(triangle.v2, triangle.v1)\r\n  let v = vector.sub(triangle.v3, triangle.v1)\r\n  let w = vector.sub(vec, triangle.v1)\r\n\r\n  let vCrossW = vector.cross(v, w)\r\n  let vCrossU = vector.cross(v, u)\r\n\r\n  if (vector3.dot(vCrossW, vCrossU) < 0) return false\r\n\r\n  let uCrossW = vector.cross(u, w)\r\n  let uCrossV = vector.cross(u, v)\r\n\r\n  if (vector3.dot(uCrossW, uCrossV) < 0) return false\r\n\r\n  let denom = memlength(uCrossV)\r\n  let r = memlength(vCrossW) / denom\r\n  let t = memlength(uCrossW) / denom\r\n\r\n  return (r + t <= 1)\r\n}\r\n\r\nfunction getTriangleArea (triangle) {\r\n  let temp = vector.cross(vector.sub(triangle.v3, triangle.v1), vector.sub(triangle.v3, triangle.v2))\r\n  let x = Math.pow(temp[0], 2)\r\n  let y = Math.pow(temp[1], 2)\r\n  let z = Math.pow(temp[2], 2)\r\n  return Math.pow(x + y + z, 0.5) / 2\r\n}\r\n\r\nfunction dot (vec1, vec2) {\r\n  return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2]\r\n}\r\n\r\nfunction getPlaneIntersect (line1, line2, triangle) {\r\n  let normal = triangle.normal\r\n  let u = vector3.dot(normal, vector.sub(triangle.v1, line1)) / vector3.dot(normal, vector.sub(line2, line1))\r\n  return vector.add(line1, vector.mult(vector.sub(line2, line1), u))\r\n}\r\n\r\nconst vector3 = { dot, rotate, normal, isInTriangle, getTriangleArea, getPlaneIntersect, memlength }\r\n\r\nexport default vector3\r\n\r\n*/ \r\n","map":{"version":3,"file":"Vector3D.js","sourceRoot":"","sources":["node_modules\\vector_class\\src\\Vector3D.ts"],"names":[],"mappings":"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","sourcesContent":["\r\nclass Vector3D {\r\n  public x: number\r\n  public y: number\r\n  public z: number\r\n\r\n  constructor (x: number, y: number, z: number) {\r\n    this.x = x\r\n    this.y = y\r\n    this.z = z\r\n  }\r\n\r\n  add (vector: Vector3D): void {\r\n    this.x += vector.x\r\n    this.y += vector.y\r\n    this.z += vector.z\r\n  }\r\n\r\n  sub (vector: Vector3D): void {\r\n    this.x -= vector.x\r\n    this.y -= vector.y\r\n    this.z -= vector.z\r\n  }\r\n\r\n  mult (scalar: number): void {\r\n    this.x *= scalar\r\n    this.y *= scalar\r\n    this.z *= scalar\r\n  }\r\n\r\n  div (scalar: number): void {\r\n    this.x /= scalar\r\n    this.y /= scalar\r\n    this.z /= scalar\r\n  }\r\n\r\n  inverse (): void {\r\n    this.x *= -1\r\n    this.y *= -1\r\n    this.z *= -1\r\n  }\r\n\r\n  mag (): number {\r\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)\r\n  }\r\n\r\n  dot (vector: Vector3D): number {\r\n    return this.x * vector.x + this.y * vector.y + this.z * vector.z\r\n  }\r\n\r\n  distance (vector: Vector3D): number {\r\n    return Vector3D.sub(this, vector).mag()\r\n  }\r\n\r\n  angle (): number {\r\n    return Math.atan2(this.y, this.x)\r\n  }\r\n\r\n  copy (): Vector3D {\r\n    return new Vector3D(this.x, this.y, this.z)\r\n  }\r\n\r\n  normalize (): void {\r\n    this.div(this.mag())\r\n  }\r\n\r\n  setMag (mag: number): void {\r\n    this.normalize()\r\n    this.mult(mag)\r\n  }\r\n\r\n  setAngle (angle): void {\r\n    const magnitude = this.mag()\r\n\r\n    this.x = magnitude * Math.cos(angle)\r\n    this.y =  magnitude * Math.sin(angle)\r\n  }\r\n\r\n  addAngle (angle: number): void {\r\n    this.setAngle(this.angle() + angle)\r\n  }\r\n\r\n  limit (scalar: number): void {\r\n    if (this.mag() > scalar) {\r\n      this.setMag(scalar)\r\n    }\r\n  }\r\n\r\n  moveTowards (vector: Vector3D, speed: number, stop: number): void {\r\n    if (this.distance(vector) > stop) {\r\n      const unit = Vector3D.normalize(vector)\r\n      unit.mult(speed)\r\n      this.add(unit)\r\n    }\r\n  }\r\n\r\n  zero (): void {\r\n    this.x = 0\r\n    this.y = 0\r\n    this.z = 0\r\n  }\r\n\r\n  static add (vector1: Vector3D, vector2: Vector3D): Vector3D {\r\n    return new Vector3D(vector1.x + vector2.x, vector1.y + vector2.y, vector1.z + vector2.z)\r\n  }\r\n\r\n  static sub (vector1: Vector3D, vector2: Vector3D): Vector3D {\r\n    return new Vector3D(vector1.x - vector2.x, vector1.y - vector2.y, vector1.z - vector2.z)\r\n  }\r\n\r\n  static mult (vector: Vector3D, scalar: number): Vector3D {\r\n    return new Vector3D(vector.x * scalar, vector.y * scalar, vector.z * scalar)\r\n  }\r\n\r\n  static div (vector: Vector3D, scalar: number): Vector3D {\r\n    return new Vector3D(vector.x / scalar, vector.y / scalar, vector.z / scalar)\r\n  }\r\n\r\n  static inverse (vector: Vector3D): Vector3D {\r\n    return new Vector3D(vector.x * -1, vector.y * -1, vector.z * -1)\r\n  }\r\n\r\n  static distance (vector1: Vector3D, vector2: Vector3D): number {\r\n    return this.sub(vector1, vector2).mag()\r\n  }\r\n\r\n  static normalize (vector: Vector3D): Vector3D {\r\n    return this.div(vector, vector.mag())\r\n  }\r\n\r\n  static cross (vector1: Vector3D, vector2: Vector3D): number {\r\n    return vector1.x * vector2.y - vector2.x * vector1.y\r\n  }\r\n\r\n  static random (x: number, y: number, z: number): Vector3D {\r\n    if (Math.random() > 0.5) {\r\n      return new Vector3D(x * Math.random(), y * Math.random(), z * Math.random())\r\n    } else {\r\n      return new Vector3D(-x * Math.random(), -y * Math.random(), -z * Math.random())\r\n    }\r\n  }\r\n}\r\n\r\nexport default Vector3D\r\n\r\n/*\r\n\r\nTO ADD\r\n\r\nimport vector from '../vector'\r\n\r\nfunction rotate (x, y, z, center, vec) {\r\n  let vecR\r\n  vecR = vector.sub(vec, center)\r\n  vecR = rotateX(vecR, x)\r\n  vecR = rotateY(vecR, y)\r\n  vecR = rotateZ(vecR, z)\r\n  vecR = vector.add(vecR, center)\r\n  return vecR\r\n}\r\n\r\nfunction rotateX (vec, t) {\r\n  let vecR = vec\r\n  let newy = vec[1] * Math.cos(t) - vec[2] * Math.sin(t)\r\n  let newz = vec[1] * Math.sin(t) + vec[2] * Math.cos(t)\r\n  vecR[1] = newy\r\n  vecR[2] = newz\r\n  return vecR\r\n}\r\n\r\nfunction rotateY (vec, t) {\r\n  let vecR = vec\r\n  let newz = vec[2] * Math.cos(t) - vec[0] * Math.sin(t)\r\n  let newx = vec[2] * Math.sin(t) + vec[0] * Math.cos(t)\r\n  vecR[2] = newz\r\n  vecR[0] = newx\r\n  return vecR\r\n}\r\n\r\nfunction rotateZ (vec, t) {\r\n  let vecR = vec\r\n  let newx = vec[0] * Math.cos(t) - vec[1] * Math.sin(t)\r\n  let newy = vec[0] * Math.sin(t) + vec[1] * Math.cos(t)\r\n  vecR[0] = newx\r\n  vecR[1] = newy\r\n  return vecR\r\n}\r\n\r\nconst memlength = (vec) => Math.pow(Math.pow(vec[0], 2) + Math.pow(vec[1], 2) + Math.pow(vec[2], 2), 0.5)\r\n\r\nconst normal = (v1, v2, v3) => vector.cross(vector.sub(v2, v1), vector.sub(v3, v1))\r\n\r\nfunction isInTriangle (vec, triangle) {\r\n  let u = vector.sub(triangle.v2, triangle.v1)\r\n  let v = vector.sub(triangle.v3, triangle.v1)\r\n  let w = vector.sub(vec, triangle.v1)\r\n\r\n  let vCrossW = vector.cross(v, w)\r\n  let vCrossU = vector.cross(v, u)\r\n\r\n  if (vector3.dot(vCrossW, vCrossU) < 0) return false\r\n\r\n  let uCrossW = vector.cross(u, w)\r\n  let uCrossV = vector.cross(u, v)\r\n\r\n  if (vector3.dot(uCrossW, uCrossV) < 0) return false\r\n\r\n  let denom = memlength(uCrossV)\r\n  let r = memlength(vCrossW) / denom\r\n  let t = memlength(uCrossW) / denom\r\n\r\n  return (r + t <= 1)\r\n}\r\n\r\nfunction getTriangleArea (triangle) {\r\n  let temp = vector.cross(vector.sub(triangle.v3, triangle.v1), vector.sub(triangle.v3, triangle.v2))\r\n  let x = Math.pow(temp[0], 2)\r\n  let y = Math.pow(temp[1], 2)\r\n  let z = Math.pow(temp[2], 2)\r\n  return Math.pow(x + y + z, 0.5) / 2\r\n}\r\n\r\nfunction dot (vec1, vec2) {\r\n  return vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2]\r\n}\r\n\r\nfunction getPlaneIntersect (line1, line2, triangle) {\r\n  let normal = triangle.normal\r\n  let u = vector3.dot(normal, vector.sub(triangle.v1, line1)) / vector3.dot(normal, vector.sub(line2, line1))\r\n  return vector.add(line1, vector.mult(vector.sub(line2, line1), u))\r\n}\r\n\r\nconst vector3 = { dot, rotate, normal, isInTriangle, getTriangleArea, getPlaneIntersect, memlength }\r\n\r\nexport default vector3\r\n\r\n*/"]}},"hash":"aa799280cc1bbeb1b559c27d6356da2b","cacheData":{"env":{}},"id":122}